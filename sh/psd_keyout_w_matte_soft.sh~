#!/bin/bash



set -e



echo "ğŸ”§ Running refined subject detection preserving line quality..."



if ! command -v python3 &>/dev/null; then

    echo "âŒ Python 3 is required."

    exit 1

fi



python3 - <<EOF

import cv2

import numpy as np



for file in [f for f in __import__('glob').glob('*.jpg') + __import__('glob').glob('*.jpeg')]:

    base = file.rsplit('.', 1)[0]

    output = f"{base}_refinedmatte.png"



    print(f"Processing: {file} â†’ {output}")



    image = cv2.imread(file)

    if image is None:

        print(f"Failed to load {file}, skipping.")

        continue



    h, w = image.shape[:2]



    # Convert to grayscale, no blur this time to preserve details

    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)



    # Use a gentle threshold to separate white background but preserve lines

    # Increase threshold value closer to 240-250 to be less aggressive

    thresh_val = 245

    _, binary = cv2.threshold(gray, thresh_val, 255, cv2.THRESH_BINARY_INV)



    # Morphology to clean small noise but keep lines (small kernel)

    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3,3))

    clean_mask = cv2.morphologyEx(binary, cv2.MORPH_OPEN, kernel, iterations=1)



    # Find contours for the largest object (the subject)

    contours, _ = cv2.findContours(clean_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    if not contours:

        print(f"No subject detected in {file}, skipping.")

        continue

    main_contour = max(contours, key=cv2.contourArea)



    subject_mask = np.zeros((h, w), dtype=np.uint8)

    cv2.drawContours(subject_mask, [main_contour], -1, 255, thickness=cv2.FILLED)



    # Dilate a little to create matte area but keep small radius for crispness

    kernel_dilate = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (9,9))

    matte_mask = cv2.dilate(subject_mask, kernel_dilate, iterations=1)



    # Create light grey-yellow matte BGRA (180,240,220,255)

    matte_color = np.array([180, 240, 220, 255], dtype=np.uint8)

    matte = np.zeros((h, w, 4), dtype=np.uint8)

    matte[:, :] = matte_color

    for c in range(4):

        matte[:, :, c] = matte[:, :, c] * (matte_mask // 255)



    # Create alpha: softly remove white pixels only over subject mask area

    white_mask = cv2.inRange(image, (245, 245, 245), (255, 255, 255))

    alpha = 255 - white_mask

    # Mask alpha outside subject as 0 for full transparency

    alpha = cv2.bitwise_and(alpha, subject_mask)



    # Convert original image to BGRA and apply refined alpha

    image_bgra = cv2.cvtColor(image, cv2.COLOR_BGR2BGRA)

    image_bgra[:, :, 3] = alpha



    # Composite foreground over matte

    fg = image_bgra[:, :, :3].astype(np.float32)

    bg = matte[:, :, :3].astype(np.float32)

    alpha_f = (image_bgra[:, :, 3] / 255.0)[:, :, np.newaxis]



    composite = (fg * alpha_f + bg * (1 - alpha_f)).astype(np.uint8)



    # Final alpha: matte_mask area fully opaque, outside transparent

    final_alpha = np.where(matte_mask > 0, 255, 0).astype(np.uint8)



    final_img = cv2.merge((composite, final_alpha))

    cv2.imwrite(output, final_img)



    print(f"Saved: {output}")



EOF



echo "âœ… Finished refined matte with preserved lines."
